<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Plunkett</title>
  <subtitle type="text"></subtitle>

  <updated>2011-08-30T09:24:35Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://blog.charleso.org" />
  <id>http://blog.charleso.org/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://blog.charleso.org/feed/atom/" />
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[A Taste of Scala]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2011/08/taste-of-scala.html" />
    <id>http://blog.charleso.org/2011/08/taste-of-scala.html</id>
    <updated>2011-08-30T20:33:00Z</updated>
    <published>2011-08-30T20:33:00Z</published>
    <category scheme="http://blog.charleso.org" term="scala" />
    <summary type="html"><![CDATA[A Taste of Scala]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2011/08/taste-of-scala.html"><![CDATA[<div class="document">
<p>Recently at the <a class="reference external" href="http://www.meetup.com/qldjvm/">Queensland JVM Meetup group</a>
I gave a <a class="reference external" href="http://www.meetup.com/qldjvm/events/26374761/">Scala introduction presentation</a>,
with some good 'ol Java bashing to boot.</p>
<p>Check it <a class="reference external" href="http://vimeo.com/groups/qldjvm/videos/28291058">out</a>. Slides <a class="reference external" href="http://blog.charleso.org/scala-talk/">here</a>.</p>
<iframe
    src="http://player.vimeo.com/video/28291058?title=0&amp;byline=0&amp;portrait=0"
    width="400" height="300" frameborder="0">
</iframe></div>
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[Java is the new COBOL]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2011/05/java-is-the-new-cobol.html" />
    <id>http://blog.charleso.org/2011/05/java-is-the-new-cobol.html</id>
    <updated>2011-08-03T20:00:00Z</updated>
    <published>2011-08-03T20:00:00Z</published>
    <category scheme="http://blog.charleso.org" term="cobol" />
    <category scheme="http://blog.charleso.org" term="java" />
    <summary type="html"><![CDATA[Java is the new COBOL]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2011/05/java-is-the-new-cobol.html"><![CDATA[<div class="document">
<p>Apart from complaining about Clearcase I have actually done some real work the
past few years.</p>
<p>Chapter 1: How we converted our entire COBOL code-base to Java (sort-of).</p>
<p><em>Already you might start to feel a sick feeling in the back of your throat.
That's normal and should pass shortly after you finish reading.</em></p>
<p>COBOL? WTF?!? This is usually the first thing people say to me when I tell them
about what I've been working on. I'm sad to say that COBOL is still very much
in <a class="reference external" href="http://en.wikipedia.org/wiki/COBOL#Legacy">use</a>.</p>
<p>The dilemma that our company faced was that our main product has been around for
many years and over time we have built up a unbelievably large code-base of COBOL,
consisting of millions of lines. Re-writing this is both costly and
time-consuming, not to mention risky. We needed another option.</p>
<p>Another serious problem is that the upfront cost of CICS, the COBOL
'application server' if you will, running on dedicated Mainframe hardware,
<em>plus</em> the cost of Micro Focus licenses, for compiling COBOL, is <em>bloody</em>
expensive. If we could run on a 100% Java stack, using open source technologies,
we could save ourselves, and our customers, cold, hard cash.</p>
<p>At this point I need to mention something 'special' about how we use COBOL. To
support a wide-range of transaction systems and databases we developed a custom
variation of the language, which included custom-built 'macros' which generate
unique code depending on the environment. While not
especially relevant to this article, this leads to larger-than-expected COBOL
(which is large enough as it is). The size of the program is significant for a
few reasons, which I'll discuss below.</p>
<p>Initially we started with <a class="reference external" href="http://www.legacyj.com/">LegacyJ</a>, a commercial product that
advertised productive COBOL to Java conversion. What was nice about using
LegacyJ was that we quickly discovered that it was, in fact, possible to
convert our code successfully and have a running system. However, we ran into
a few serious problems that made us hesitate.</p>
<p>Firstly, the Java generated by LegacyJ was quite lengthy and often
didn't compile due to the length of some methods and number of fields.
Apparently Java has a <a class="reference external" href="href=&quot;http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">limit</a>, not that you would ever conceivably reach it. To
work around this I had to re-parse the Java to break these methods into smaller
chunks and introduce a hierarchy of classes to work-around the field limit.
Yuck.</p>
<p>Secondly, the classes generated by LegacyJ didn't separate the idea of 'meta'
information such as variable types from runtime data. For each instance of a
program, variables had effectively duplicate copies of type information,
resulting in an extra-large memory footprint.</p>
<p>The other issue, and perhaps the most compelling, was that of money; LegacyJ
was not cheap. We were trading one expensive platform, CICS, with another.</p>
<p>At the same time the following <a class="reference external" href="http://www.infoq.com/news/2009/07/cobol-to-java">article</a> appeared, introducing an open-source
COBOL to Java converter called <a class="reference external" href="http://code.google.com/p/naca/">NACA</a>. I tried it almost immediately but quickly
found that many of our COBOL programs didn't compile due to some commands that
NACA hadn't implemented. At first I gave up and went back to our LegacyJ
integration. It was only later, after taking a second look, that I realised
there was much more potential on NACA's generated Java and general approach.</p>
<p>The most obvious was that the Java was actually readable! At least if you <a class="reference external" href="http://code.google.com/p/naca/source/browse/trunk/NacaSamples/src/online/ONLINE1.java">count</a>
this as readable. NACA actually checked-in their Java files after the
conversion, so the code had to be both readable and maintainable. This
also had the nice side-effect of allowing our absolutely massive generated
COBOL programs to compile (in 99% of cases anyway).</p>
<p>In addition there was a separate and static class structure representing the
program definition, meaning that each program required less memory.</p>
<p>I was given some time to investigate the possibility of making NACA work with
our unique flavour of COBOL. Fortunately it turned out there wasn't too much
<a class="reference external" href="https://github.com/charleso/naca">missing</a> and I managed to get a working prototype in a reasonably short period
of time. After that the decision to switch to a cheaper and open-source
alternative which we could control wasn't hard to make and we haven't looked
back since.</p>
<p>To avoid making this post longer that it already is I might save the important
discussion of performance for another day. In short our pure-Java application
runs surprisingly quickly. The biggest bottleneck is, without a doubt, one of
memory. Running an entire-COBOL runtime within the JVM is obviously costly in
terms of memory, not helped by our generated COBOL and vast code-base.</p>
<p>Do I recommend this approach to others? <em>Absolutely</em>, without a
doubt. There seems to be <a class="reference external" href="http://stackoverflow.com/questions/1029974/experience-migrating-legacy-cobol-pl1-to-java/1061829#1061829">people</a> advising against a direct port, or at least
<a class="reference external" href="http://stackoverflow.com/questions/1796906/cobol-migrations-strategies/1810332#1810332">re-thinking</a> the problem first. For us the issue is one of scale. There simply
isn't enough time/money to re-write everything, at least not in this decade. We
needed to do something <em>now</em>; something we could <em>guarantee</em> would continue to
work.</p>
<p>The benefits of running a pure-Java stack are, alone, compelling. One example
that springs to mind is that of tracing. Once upon a time we would need to ask
customers with a bug to recompile specific applications in trace mode in the
vain hope that we actually knew where the problem was. Now we can leverage
powerful Java <a class="reference external" href="http://logback.qos.ch/">logging</a> (no, not that useless java.util.logging) and have full
tracing across the entire stack; something that is invaluable for customer
support.</p>
<p>So, while I hate the idea of granting further life to our hideous COBOL demon,
from a business point-of-view it has been crucial in the continued success and
evolution of our product; giving us breathing room to slowly migrate COBOL
logic to 'normal' Java applications while guaranteeing our business logic
continues to serve our customers. Or at least that's what our marketing
brochures say; for me it was fun.</p>
</div>
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[Blogofile]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2011/05/blogofile.html" />
    <id>http://blog.charleso.org/2011/05/blogofile.html</id>
    <updated>2011-06-02T20:21:00Z</updated>
    <published>2011-06-02T20:21:00Z</published>
    <category scheme="http://blog.charleso.org" term="github" />
    <category scheme="http://blog.charleso.org" term="blogofile" />
    <summary type="html"><![CDATA[Blogofile]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2011/05/blogofile.html"><![CDATA[<div class="document">
<p>Inspired by my friend <a class="reference external" href="http://buffered.io/2011/02/15/now-powered-by-blogofile/">OJ</a>, I've decided to make the switch to Blogofile.
I guess I have too much time on my hands.</p>
<p>There isn't much I can say on this subject that hasn't already <a class="reference external" href="http://mike.pirnat.com/2010/12/18/why-i-switched-to-blogofile/">been</a> <a class="reference external" href="http://morgangoose.com/blog/2010/09/28/switching-to-blogofile/">said</a>.
<a class="reference external" href="https://github.com/EnigmaCurry/blogofile/blob/master/converters/blogger2blogofile.py">This</a> script came in handy to convert my Blogger posts across.</p>
<p>My biggest hurdle was finding a new host <em>and</em> being a complete cheapskate.
I couldn't seem to find a free and simple HTML site. I started to think
about Dropbox, until I realised that they don't respect index.html files.
Fortunately <a class="reference external" href="http://manuel-ohlendorf.de/blog/2010/12/23/hosting-a-blogofile-blog-on-github-with-github-pages/">someone</a> had a neat idea - host it on <a class="reference external" href="http://pages.github.com/">GitHub</a>!</p>
<p>One thing would have been <em>nice</em> is a selection of out-the-box themes;
but completely understandable that there isn't.
In the meantime I ported my current Blogger <a class="reference external" href="http://www.blogcrowds.com/resources/blogger-templates/13-565">theme</a>, which was surprisingly
painless.</p>
<p>I'll probably be tweaking bits-and-pieces of the site in the next few weeks,
like a child playing with a new toy. Procrastinating instead of, say,
writing new blog posts.</p>
</div>
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[Who needs documentation anyway?]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2011/05/who-needs-documentation-anyway.html" />
    <id>http://blog.charleso.org/2011/05/who-needs-documentation-anyway.html</id>
    <updated>2011-05-20T19:41:18Z</updated>
    <published>2011-05-20T19:41:00Z</published>
    <category scheme="http://blog.charleso.org" term="restructuredtext" />
    <category scheme="http://blog.charleso.org" term="markup" />
    <category scheme="http://blog.charleso.org" term="documentation" />
    <summary type="html"><![CDATA[Who needs documentation anyway?]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2011/05/who-needs-documentation-anyway.html"><![CDATA[
So, we have a dilemma at work. How do the developers and documentation teams
collaborate on a single set of documentation files while using familiar tools?
Is such a thing possible or am I dreaming?
<br /><br />
Currently the documentation team at our work uses
<a href="http://www.author-it.com/">Author-it</a>, a full-blown authoring
'solution'. For some time we, the developers, were been sent Word documents
which we updated and emailed back. At this point the source control fanatic in
me started to twitch. It's a document - just like source code - can I see who
did what changes? How do two people work on the same document at the same time,
and what about conflicts? Can I have multiple version of the same document? The
other problem was one of cost; Author-it is too expensive to justify individual
licenses for developers.
<br /><br />
We had talked about switching to a more text-based documentation system
on-and-off for some time. Finally I cracked and decided to just do it.
<br /><br />
<a href="http://en.wikipedia.org/wiki/LaTeX">Latex</a> was the first
possibility that surfaced. However, as I thought about it more the idea of
everyone having to learn obtuse Latex syntax before writing a single-line of
documentation was a little off-putting. Note: I really do like Latex, but I
felt like it might have been overly complicated for our situation.
<br /><br />
The second alternative was to use a publication
<a href="http://www.dclab.com/dita_docbook.asp">format</a> like
<a href="http://www.docbook.org/">Docbook</a> or
<a href="http://en.wikipedia.org/wiki/Darwin_Information_Typing_Architecture">DITA</a>.
While certainly a powerful way to group content, the prospect of living in XML
hell didn't enthuse me all that much. I already get enough of that in Java-land
thank you very much.
<br /><br />
My final option was to use a lightweight markup langague, like
<a href="http://daringfireball.net/projects/markdown/">Markdown</a> or
<a href="http://docutils.sourceforge.net/rst.html">reStructureText</a> (ReST),
which GitHub actively promotes for their README files. This felt like the right
fit for us, and without further consultation I converted our current internal
word documents to ReST, added them to Git and created a Jenkin job to output
<a href="http://code.google.com/p/rst2pdf/">PDF</a> and HTML files. Bam!
<br /><br />
At this point us developers were happy again. We were back to using our
favourite source control for collaboration, without have to stuff around with
emailing Word documents. We could quickly edit text files, use source control
to track/merge changes and didn't have to worry any more about niggling
presentation issues. My manager, on the other hand, who was away at the time,
was <i>not</i> so pleased. (I swear this had nothing to do with the timing of
my rash decision).
<br /><br />
For us developers the idea of using a text editor to edit a document is a
fairly comfortable one. For people used to - and who enjoy using - Word this
was in some ways a big step backwards. No spell checking, no auto-complete, no
drag 'n' drop. All that good stuff. Another complaint he had was about
presentation - the PDF output wasn't slick enough to be used officially.
Finally, if we wanted to switch to something else, ReST seemed to lack in some
of the more powerful <a href="http://docs.oasis-open.org/dita/v1.0/archspec/topicover.html">concepts</a>
required to support <a href="http://en.wikipedia.org/wiki/Single_source_publishing">single-source</a>
publishing.
<br /><br />
I could definitely be wrong but it feels like nothing has quite <i>nailed</i>
this space in the space, at least in the OSS community. What would certainly
help is a powerful and easy to use  editor. Perhaps a plugin for Open Office
would do the trick? Alternatively a browser-based editor, not too unlike
<a href="http://rst.ninjs.org/">this</a>.
<br /><br />
We're currently in a holding pattern at the moment. Developers are still
(happily) using ReST, but the 'official' stuff is being written by the
documentation team. Us and them.
<br /><br />
I see a couple of available options:<br />
<ol>
    <li>What am I talking about, emailing Word documents around is fine - stop complaining.</li>
    <li>Embrace Author-it and see if it can support more collaborators. Just looking at their website briefly it seems like they have an <a href="http://www.author-it.com/index.php?page=reviewer">online</a> review mode.</li>
    <li>Meet my boss half-way, he can live without the nice GUI but we switch to a singe-source markup language like DocBook/DITA.</li>
    <li>Everyone else be damned; developers rule; reStructuredText it is!</li>
</ol>I'm curious what other people have done in similar situations.<br />
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[Java logging and per-user tracing]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2011/05/java-logging.html" />
    <id>http://blog.charleso.org/2011/05/java-logging.html</id>
    <updated>2011-05-14T06:32:31Z</updated>
    <published>2011-05-14T05:20:00Z</published>
    <category scheme="http://blog.charleso.org" term="logging" />
    <category scheme="http://blog.charleso.org" term="java" />
    <category scheme="http://blog.charleso.org" term="logback" />
    <summary type="html"><![CDATA[Java logging and per-user tracing]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2011/05/java-logging.html"><![CDATA[
This is a fairly short post about my brief experiences with logging in Java. I
realise it's 2011 and logging is very unsexy, but I thought I'd share anyway.
<br /><br />
Let me just say this straight-up - Java Logging you are <i>completely fucking
useless</i>.  It boggles the mind how badly Sun screwed up the implementation
of something so simple but yet so fundamental. It's logging for Christ's sake;
how hard can it be?!? 
<a href="http://www.bileblog.org/2003/10/javautillogging-shoddiness/">This</a>
captures the essence of my feelings, so I'll leave it at that.
<br /><br />
One thing I <i>did</i> want to mention is
<a href="http://logback.qos.ch/">Logback</a> and the awesome
<a href="http://logback.qos.ch/manual/appenders.html#SiftingAppender">SiftingAppender</a>.
Logback is the successor to the much loved 
<a href="http://logging.apache.org/log4j/">Log4J</a>, written by the same dude and
<a href="http://logback.qos.ch/reasonsToSwitch.html">addressing</a> some of the
problems with the original. 
<br /><br />
My manager wanted a way for our users to enable <i>individual</i> logging on
the server and not require any meddling on the server by an administrator. A
quick Google revealed
<a href="http://stackoverflow.com/questions/840465/have-you-seen-an-appender-that-would-log-to-separate-files-based-on-ndc-in-log4j/925978#925978">this</a>
and from there it wasn't hard to implement a start/stop trace button on each
page which harnesses
<a href="http://www.slf4j.org/api/org/slf4j/MDC.html">MDC</a> for per-user
logging. On completion the trace can either be downloaded or emailed directly
from the server to the system administrator or bug tracker.
<br /><br />
Honestly, if/when I ever work on another online application I will almost
certainly re-implement something very similar again. Being able to capture a
trace of everything from the server for a single user session has proven to be
an invaluable tool for diagnosing bugs. Give it a whirl!
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[Death of a Clearcase]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2011/05/death-of-clearcase.html" />
    <id>http://blog.charleso.org/2011/05/death-of-clearcase.html</id>
    <updated>2011-05-14T06:33:02Z</updated>
    <published>2011-05-07T02:37:00Z</published>
    <category scheme="http://blog.charleso.org" term="clearcase" />
    <category scheme="http://blog.charleso.org" term="git" />
    <summary type="html"><![CDATA[Death of a Clearcase]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2011/05/death-of-clearcase.html"><![CDATA[
Well it's been <span>quite</span> some time since my last post. Time has moved
on in many respects, and yet it also feels like very little has changed.
Someone at work suggested that I should add a final post to the saga of
migrating away from Clearcase at work.
<br /><br />
The good news is: we won!
<br /><br />
That is to say that we now use Git for a majority of projects at work, with the
last few being migrated as we speak. Huzzah!
<br /><br />
How did it happen?
<br /><br />
Sadly my persistent nagging made very little difference in the end.
Fortunately, however, money did; the cost of continued licensing of Clearcase
was not attractive to the bean counters upstairs. Combined with the increasing
globalisation of our team meant that Git, or at least a free DVCS, became a
very real option (free being the operative word). Mercurial was the first
choice, but by those who didn't have any hands-on experience with either; a
mistake I have blogged about earlier. Given that my team and I had been using
Git in-anger for at least 6 months we fortunately (or unfortunately) managed to
convince them to think again.
<br /><br />
We decided to host our source in The Cloud; specifically on GitHub. Now GitHub
is an impressive site and I use it for all my open source projects. However, I
do have one minor gripe: sadly GitHub has 
<a href="http://support.github.com/discussions/organization-issues/19-grant-permission-to-add-new-members-only">not yet</a>
implemented fine-grained security for Organisations. Given that the
majority of users are open source and would most likely fork-on-write this
makes sense. In our environment where we effectively work on a single
repository it would be nicer if we could delegate a project leader or leaders
and have them add/remove users for their team. Add the moment only 'Owners' can
appear to do that, who can then also  see billing information. The other
problem is that with push authorisation you get force-push as well, which can
be extremely dangerous in the hands of some. Not an ideal situation to be sure.
Before the official migration we used the awesome
<a href="https://github.com/sitaramc/gitolite">gitolite</a> which handled security
beautifully, even down the branch/force push level. I would hope that at some
point GitHub will adopt something more like that; but for now things are still
1 millions time better than using you-know-what and we can't complain too much.
<br /><br />
I should add that the obvious rebuttal to this complaint is that we probably
need to consider switching to a more distributed/pull-model of collaboration,
where everyone has their own repository. I don't disagree with this
necessarily, but having a push model gives us high visibility of changes and a
quick development cycle. A discussion for another day perhaps.
<br /><br />
And how about the users? Are they happy?
<br /><br />
As much as I love Git, I'm not finding it any easier to teach some of the finer
points of Git and DVCS, and people still ask me for help on a daily basis. It
does take a while for the difference between checkout and reset to sink-in,
which I can emphasise with. Also multiple branches from within one repositories
is something that causes confusion to begin with. Finally I am definitely well
past getting to the point where I think overriding rebase as a default of pull
is more hassle than its worth. Especially when people merge a support branch
and then pull again, resulting in both the merge being undone and a duplicate
commit being made. It doesn't help that Git does all this without a single
warning or message.
<br /><br />
I guess what I've leant is that some developers just want to get their work
done in peace. They don't really care about the finer points of source control,
and they especially don't care about indexes, rebasing, DAGs or any other such
nonsense. Perhaps in this respect Mercurial might have been a better choice?
Less sharp edges for people to run into, and I could always run
<a href="http://hg-git.github.com/">hg-git</a> locally to keep me happy. Who knows
at this point. The decision has been made; the ship most definitely sailed. On
the upside, I'm fairly sure most, if not all, people are happy about the switch
away from Clearcase. The world is a better place for it too.
<br /><br />
My next obsession? Scala!
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[The DVCS Wars]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2009/08/git-vs-mercurial.html" />
    <id>http://blog.charleso.org/2009/08/git-vs-mercurial.html</id>
    <updated>2009-08-02T16:31:57Z</updated>
    <published>2009-08-02T02:42:00Z</published>
    <category scheme="http://blog.charleso.org" term="dvcs" />
    <category scheme="http://blog.charleso.org" term="mercurial" />
    <category scheme="http://blog.charleso.org" term="git" />
    <summary type="html"><![CDATA[The DVCS Wars]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2009/08/git-vs-mercurial.html"><![CDATA[
What is it about us nerds that dictates every discussion must be a war of some
description? It isn't enough that we have two (or more) great technologies at
our disposal, we also have to fight about it and of-course we have to be 
<a href="http://xkcd.com/386/">right</a>. For example the age-old conflict between
Vi and Emacs seems to continue today, as passionately as ever. And why not?
There's nothing like a good ol' fashioned flame war to get the blood pumping.
<br /><br />
This post, in all fairness, should really be called "Why I switched from
Mercurial to Git". I actually quite like Mercurial and it was the original DVCS
that opened my eyes to a world beyond SVN. Upon first hearing about the
exciting  concept of DVCS I knew that I needed to get my hands on one ASAP. But
of course it couldn't just be <span>any</span> DVCS, it had to be the best one.
So I did some more reading, scoured blogs for any material I could find on the
topic so I could make the perfect choice. And I did. Only I picked the wrong
perfect one...
<br /><br />
Mercurial has so many good things going for it. The command line is clean and
simple, and for SVN escapees feels very much like home. It's written in Python,
which helps on Windows, and has a nice plugin architecture. In addition it has
a good balance of speed and size, not requiring any silly garbage collection.
Oh how I used to laugh at those poor Git fools, why couldn't they see the folly
of their ways. So what changed? I guess curiosity got the better of me. I read
<a href="http://www.rockstarprogrammer.org/post/2008/apr/06/differences-between-mercurial-and-git/">one</a>
<a href="http://thunk.org/tytso/blog/2007/03/24/git-and-hg/">too</a> many
pro-Git articles and realised I might just be missing something.
<br /><br />
What makes Git worth switching too then? In short, 
<a href="http://keithp.com/blogs/Repository_Formats_Matter/">the repository format</a>.
Everything else, in my opinion, is just porcelain. The defining moment for me
was when I learnt about
<a href="http://www.gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html">reflog</a>.
So anything I commit is safely backed-up for 90 days regardless of what I do to
the visible history? Count me in!
<br /><br />
The safety net of Git's repository format in this respect is liberating.
Commands like rebase are not so much 'modifying history' as modifying your view
of history, because you can always retrieve the old version (within 90 days) if
you need it again. On the other hand when you modify the history in Mercurial
you <span>really are</span><span> </span>modifying the history. Whoops you've
just stripped that commit from your repository; I hope you made a backup. This
is one of those fundamental differences between Git and Mercurial, carefully
<a href="http://www.nabble.com/Advocacy-vs.-git-tp23221258p23226084.html">considered</a>
and implemented by their original designers. It means that in Git you have the
trade-off of having to run a gc occasionally to remove those pesky unused
objects. I'm cool with that if it means I get my reflog and a rebase that is
100% refundable, no questions asked. I should hastily add that I've never
'lost' a commit and I'm certainly not trying to suggest that Mercurial is
unsafe. For me personally it's about that extra layer of comfort and freedom
that Git provides.
<br /><br />
After that everything else seemed to just fall into place. I'd never really
liked Mercurial's (previous) answer to local branches:
<a href="http://mercurial.selenic.com/wiki/MqExtension">MQ</a>. Having to learn a
whole new set of commands to essentially do the same thing. I kept forgetting
which 'q' command did what. Why should I even <span>have </span>to remember
different commands, why can't I just commit and rebase later? Of course I'm
being simplistic here, and MQ is a very powerful tool, but what I really wanted
was a way to work as normal and <span> </span>decide 
<a href="http://tomayko.com/writings/the-thing-about-git"><span>later</span></a>
how to sync my changes.
<br /><br />
I find something strangely fascinating about version control, and I don't think
I'm the only one either. It seems to be a topic that draws an unusual amount of
attention, much to the
<a href="http://www.nabble.com/gnome-dvcs-survey-results-tp21297884p21368916.html">continual</a>
<a href="http://www.nabble.com/Re%3A-how-to-squash-commits-p23049314.html">annoyance</a>
of their creators I'm sure. Like everything in life, there is no absolute right
or wrong in regards to version control, as much as we'd like to argue there is
[1]. What is perfect for someone may be hell for another. Many people have
happily switched from Git to Mercurial, and while I think they're crazy I think
I understand why. My rookie mistake was not playing with all the alternatives
in the beginning. Git has turned out to be the ideal tool<span>
</span>for<span> me</span>; it compliments the way I work and think in a way
that Mercurial didn't or can't by design.
<br /><br />
[1] Unless of course you prefer Clearcase, in which case you're ugly and
stupid. :-P
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[ClearCase strikes back]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2009/07/clearcase-strikes-back.html" />
    <id>http://blog.charleso.org/2009/07/clearcase-strikes-back.html</id>
    <updated>2009-07-13T04:05:55Z</updated>
    <published>2009-07-12T01:57:00Z</published>
    <category scheme="http://blog.charleso.org" term="svn" />
    <category scheme="http://blog.charleso.org" term="git" />
    <category scheme="http://blog.charleso.org" term="java" />
    <category scheme="http://blog.charleso.org" term="python" />
    <category scheme="http://blog.charleso.org" term="dvcs" />
    <category scheme="http://blog.charleso.org" term="linux" />
    <category scheme="http://blog.charleso.org" term="clearcase" />
    <summary type="html"><![CDATA[ClearCase strikes back]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2009/07/clearcase-strikes-back.html"><![CDATA[
So it's been almost a year since my last post and I obviously haven't had much
to say. I'm back to talk about the exact same thing, again. I really need to
find something other than version control to obsess about...
<br /><br />
Recently I made the switch to Ubuntu at work. This left me without ClearCase,
as it <a href="http://www-01.ibm.com/support/docview.wss?rs=984&uid=swg21239315">requires</a>
some derivative of enterprise Redhat or SUSE, which didn't interest me in the
slightest. I can only assume this is partially due to the complexities of
managing a separate binary kernel module required by MVFS, their virtual
filesystem. As an alternative Rational seem to be pushing their 
<a href="http://www.ibm.com/developerworks/rational/library/05/0809_CCDemo/">Java implementation</a> 
ClearCase Remote Client (CCRC). CCRC is essentially an Eclipse plugin
communicating to a server - via a mixture of Web Services and RPC, which in
turn has the 'real' client installed. As you would expect this seems to have
some performance trade-offs, and it also feels to me quite unstable at the
moment, often throwing strange errors unrelated to ClearCase.
It's certainly better than nothing though.
<br /><br />
This, of course, raised immediate problems for me as I refuse to go back to
using ClearCase directly now that I've tasted the good (and fast) Git life.
Because I obviously can't seem to help myself I 
<a href="http://github.com/charleso/gitcc4j/tree/master">ported</a> the gitcc to
Java to use their new libraries, although it's <span>definitely</span> the last
time.
<br /><br />
One good thing to come out of this new version is the cross-platform ability to
login as any user, bypassing the domain-specific authentication that is
normally used. At least in my situation ClearCase was authenticated via our
Windows domain and I could see no quick and safe way to switch between users.
This was/is essential for us to preserve the identity of the author of each
commit in ClearCase. I strongly suspect there is a way around this, but for the
life of me I couldn't think of any. The one alternative that occured to me
would have been to run gitcc on something other than Windows configured with
NFS and 'sudo su' to each user as required. For reasons I am unable to
articulate I wasn't all that happy with the idea and never bothered.
<br /><br />
I've been running a gitcc daemon at work for the past week with great success.
It's funny how the speed difference of pushing/pulling affects your work
habits. Before I used to watch the checkin and rebase console output, like
being glued to TV. Especially because we're using UCM this could take up to a
few minutes to do it's rebase/deliver business, which would distract me and I
would often 'hold off' on pushing or pulling because I wanted to do it all in
one hit to save time. I no longer have that problem, being able to 'fetch'
whenever I like, knowing it only takes (literally) a second to complete. Of
course in the background the daemon is chugging away, syncing with ClearCase at
its own slow-and-steady pace.
<br /><br />
Git seems to be finally taking off at work, after a slow and bumpy start.
Personally I'm thrilled to be using Git at work regardless of what anyone else
is doing. However some part of me isn't satisfied with just stopping there. It
pains me to see others at work using a sub-par tool when I know there is a much
better one available. The worst part is that most of them don't even know what
they're missing, having never used anything else. Having originally come from
SVN I couldn't bear to have to checkout files every time I wanted to make a
change and I knew it didn't have to be that way. A co-worker even commented
that they 'like' knowing when they're modifying files just in case they
accidentally typed something without realising it. That may be true, but I
strongly suspect after using Git for a few days they would be unlikely to
revert. That's not even taking into consideration the many other benefits of
using a DVCS - like local branching.
<br /><br />
What remains is the biggest hurdle: taking it to the 'next level'. A handful of
developers are currently using it individually, but now that we have daemon
available we can start to look at essentially ditching ClearCase, at least for
our team. Part of the problem with working for a 'largish' company is their
slow and cautious approach when introducing new technologies. From their
perspective they have to consider what happens if I get run over by a bus
tomorrow (those damn buses - always threatening to run us over). No one else
really has the same intimate knowledge of gitcc and its inner workings. How
much time and money would be wasted having to fix it, or revert to ClearCase if
I was no longer there? The other issue is one of training and expertise. Now
you have the problem of supporting <span>two</span> completely different source
control systems, including training for, and maintenance of, both.
<br /><br />
The final problem that I face is one of Git's maturity. I love Git. Without a
doubt it is the most advanced version control system available today. Sure it's
got<span> more</span> than its fair share of warts, but I wouldn't use anything
else (yes I know about Mercurial, and in any other universe without Git I would
be using it quite happily). Unfortunately what it lacks at the moment is all
that boring Windows GUI and administration tools that managers and
non-technical people need (and I don't just mean TortoiseGit). I'm sure they'll
be here soon enough, but in the meantime I would still hesitate if asked 'is
Git ready'.  The problem is that the viable alternative, at this very second in
time, would most likely be SVN, which isn't a <span>bad</span> system, but when
compared to any modern DVCS it looks increasingly archaic. If we switched to
SVN now I strongly suspect there would be pressure to switch (again) to
something more powerful in the not-too-distant future.
<br /><br />
I'd love to use Git at work as our sole version control. Unfortunately as a
developer I don't really have the time or patience to play politics and ensure
that all aspects of a migration are planned for. However, it seems silly to me
that if a majority of your developers start to use an alternative system for
any aspect of work then there isn't some reflection on your current one and how
you can make your working environment that much more productive. I'm not
suggesting for a second that we replace ClearCase tomorrow. Instead I am simply
proposing a gradual adoption, or at least trial, of Git over ClearCase. Hell,
we're pretty much doing that now anyway, just not officially.
<br /><br />
Finally, the other revelation to come out of this is how truly entrenched in
Java I have become. I found with the Python implementation I would often worry
about making changes because I would have to spend part of the time
investigating how to implement something 'in Python' rather than just being
able to focus on the problem at hand. This has nothing to do with Python, it
still remains a fantastic language, but perhaps says something about me getting
older and less adaptable when learning new things. I hope I never reach that
point where I'm too afraid to try something new, although I'm certainly
becoming far less likely to (at least seriously) learn a new language in my
spare time. I'm just hoping one of these days I get to use Haskell at work. :)
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[A Clearcase for Git]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2008/10/clearcase-for-git.html" />
    <id>http://blog.charleso.org/2008/10/clearcase-for-git.html</id>
    <updated>2008-11-10T13:23:37Z</updated>
    <published>2008-10-25T19:30:00Z</published>
    <category scheme="http://blog.charleso.org" term="python" />
    <category scheme="http://blog.charleso.org" term="clearcase" />
    <category scheme="http://blog.charleso.org" term="git" />
    <summary type="html"><![CDATA[A Clearcase for Git]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2008/10/clearcase-for-git.html"><![CDATA[
My introduction to Clearcase began about two years again at my now current
current job. Coming from SVN it seemed, and still is, so overly complicated and
slow. What is this "config spec" you speak of? Anyway, I could write essays
devoted to my loathing of Clearcase but this is not what this is about.
<br /><br />
I've been tempted for quite some time to introduce a DVCS, <span>any</span>
DVCS, into the mix to make my life easier. However, I was concerned it may end
up being just as much work as just sticking with Clearcase. I certainly didn't
want to have to stuff around with manually deleting and adding files and native
moving/renaming was also essential.
<br /><br />
I found some<a href="http://genaud.net/2008/08/clearcase-globally-git-locally/"> helpful scripts</a>,
but nothing that really <span>just worked</span>.
<br /><br />
Anyway, I finally got my act together and put together a simple bridge which
can push and pull changes into Git. About bloody time!
<br /><br />
<a href="http://github.com/charleso/git-cc/tree/master">http://github.com/charleso/git-cc/tree/master</a>
<br /><br />
The README is probably a good place to start for anyone interested.
<br /><br />
<span>Please note:</span> It's still very much a work in progress. However, I'm
already using it at work to much joy and relief. Not more pointless checking
out on private branches. No more VOB locking or stupid branch renaming for
releases. Just sweet, sweet Gitness.
<br /><br />
A few basic examples:
<br />
<pre>
    python gitcc.py init
    d:\views\your_clearcase_view
    python gitcc.py rebase
    # Obligatory comment about getting coffee and doing work
    python gitcc.py checkin
</pre>
That's about it really. I'm interested to see if anyone else finds this
useful or has any suggestions.
<br /><br />
Finally, it was so refreshing to finally work with Python again. I'd forgotten
how simple and concise it is to use. I'm so entrenched in Java that, like an
addiction, it's too easy to fall back on. That's not to say I'm addicted to
Java, nor do I hate it particularly, but it's just so comfortable and I just
don't have to think about it anymore. Sad really.
]]></content>
  </entry>
  <entry>
    <author>
      <name>Charles O'Farrell</name>
      <uri>http://blog.charleso.org</uri>
    </author>
    <title type="html"><![CDATA[Flex-o-matic]]></title>
    <link rel="alternate" type="text/html" href="http://blog.charleso.org/2008/08/flex-o-matic.html" />
    <id>http://blog.charleso.org/2008/08/flex-o-matic.html</id>
    <updated>2008-08-07T06:03:16Z</updated>
    <published>2008-08-07T01:53:00Z</published>
    <category scheme="http://blog.charleso.org" term="flex" />
    <category scheme="http://blog.charleso.org" term="automated" />
    <summary type="html"><![CDATA[Flex-o-matic]]></summary>
    <content type="html" xml:base="http://blog.charleso.org/2008/08/flex-o-matic.html"><![CDATA[
<a href="http://selenium-ide.openqa.org/selenium-ide.gif"><img src="http://seleniumhq.org/projects/ide/selenium-ide.gif" alt="" border="0" /></a>
A few weeks ago I investigated Flex automated testing to determine it's
feasibility for our new Flex project. On Wednesday my boss has asked me to
follow through with that original investigation and get it up-and-running on
our build loop ASAP.
<br /><br />
The tools I originally looked at:<br />
<ol>
<li>
    <a href="http://en.wikipedia.org/wiki/HP_QuickTest_Professional">HP QuickTest Professional</a> or QTP. 
This is the big daddy of Flex automation testing, and
costs an arm and a leg. The funny thing is I couldn't seem to get this working
last time. That and it looks like an old Windows 95 app (superficial I
know).
</li>
<li>
    <a href="http://riatest.com/">RIATest</a>. In many ways
this is the nicest of the tools. Quick, simple and it just works (TM). However
it's in very early stages, has its own IDE/language and only works on
Windows.
</li>
<li>
    <a href="http://www-306.ibm.com/software/awdtools/tester/functional/">Rational Functional Tester</a> or RFT,
a set of Rational plugins for Eclipse. The business preferred option as we use this for other products as well.
<br />
</li>
<li>
    <a href="http://www.adobe.com/devnet/flex/samples/custom_automated/">Custom Automated Agents</a>, the adobe sample for automation testing. It's worth
noting that all the above products are essentially just rebadged versions of
this. This has the most power of all these tools, but is very bare bones and
quite complicated to understand.
<br />
</li>
</ol>
Originally I had decided on RFT a few weeks ago and wrote some basic tests.
However, today I spent some more time with it and ran into a few snags.
<br /><br />
Firstly our toolbar is a Flex MenuBar, which (for some <span>stupid</span>
reason) doesn't handle ItemClick events for root items. Without this you can't
perform the simplest of actions like searching. To get this working we would
<span>have</span> to use something else. Strike one.
<br /><br />
Secondly the Grid data verification points were now returning blanks in every
cell. After some snooping it turns out setting a custom itemRenderer for
columns (ie combobox or checkbox) causes this to happen. Sadly we need to do
this and I couldn't seem to fix the problem. Strike two.
<br /><br />
While none of these are show stoppers it made me realise I really didn't like
using RFT, it felt flaky, so I thought I'd better re-examine my options.
<br /><br />
The other, as of yet unexplored option, was <a href="http://selenium.openqa.org/">Selenium</a>. 
Just the other day (literally) the<a href="http://sourceforge.net/projects/seleniumflexapi/"> new flex API</a>
was released. Behind the scenes this is simply an exposed API via the Flex 
<a href="http://livedocs.adobe.com/flex/3/langref/flash/external/ExternalInterface.html">ExternalInterface</a>
(basically a Flex/Javascript bridge). As I was looking at this I realised we
could just expose our own custom API to compliment Selenium's.
<br /><br />
For some reason this latest option appeals to me as it potentially grants the
most power and least amount of headaches. Using the above tools feels like
we're getting locked into a specific way of using Flex. When something doesn't
work, like it did today, there isn't much we can do except change
<span>our</span> application to fit the required mold. Instead it would be nice
if the automated tools were as <span>flex</span>ible as we need them to be.
<br /><br />
What we loose is the recording capability, which I don't think is a huge loss
(but sad). Some of our other functional tests at work are also written by hand.
It will also require some more initial tweaking while we flesh out our own
internal API. My other concern is that it's not <span>exactly</span> the same
as users interacting with the app, but then again neither are the above tools.
<br /><br />
I'm still not sure at this stage which option I'm going to settle on. Time is
of the essence, and I really need to have something to show by next week. I'm
hoping with some more testing tomorrow, Selenium will be just what the doctor
ordered.
]]></content>
  </entry>
</feed>
